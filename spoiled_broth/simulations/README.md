# Simulation Module Refactoring

## Overview

The large `utils.py` file has been refactored into individual modules for better maintainability and organization. Each class now has its own file while maintaining backward compatibility.

## New File Structure

```
spoiled_broth/simulations/
├── __init__.py                 # Package initialization with imports
├── utils.py                    # Original file (kept for backward compatibility)
├── simulation_config.py        # SimulationConfig class
├── path_manager.py            # PathManager class
├── controller_manager.py      # ControllerManager class
├── ray_manager.py             # RayManager class
├── data_logger.py             # DataLogger class
├── action_tracker.py          # ActionTracker class
├── video_recorder.py          # VideoRecorder class
├── game_manager.py            # GameManager class
├── simulation_runner.py       # SimulationRunner class
└── simulation_utils.py        # Utility functions
```

## Classes and Their Files

1. **SimulationConfig** → `simulation_config.py`
   - Configuration class for simulation parameters
   - Handles cluster settings, timing, video settings, grid settings

2. **PathManager** → `path_manager.py`
   - Manages paths and directories for simulation runs
   - Handles path setup and grid size detection from maps

3. **ControllerManager** → `controller_manager.py`
   - Manages RL controller initialization and configuration
   - Determines controller types and initializes agent controllers

4. **RayManager** → `ray_manager.py`
   - Manages Ray cluster initialization and shutdown
   - Simple static methods for Ray operations

5. **DataLogger** → `data_logger.py`
   - Handles logging of simulation state and action data
   - Creates CSV files and configuration files

6. **ActionTracker** → `action_tracker.py`
   - Tracks agent actions with detailed logging and timing
   - Handles action start/end tracking and cleanup

7. **VideoRecorder** → `video_recorder.py`
   - Handles video recording with HUD overlay
   - Manages video encoding and frame processing

8. **GameManager** → `game_manager.py`
   - Manages game instance creation and configuration
   - Handles game state reset and factory creation

9. **SimulationRunner** → `simulation_runner.py`
   - Main class for running complete simulations
   - Orchestrates all other components for full simulation execution

10. **Utility Functions** → `simulation_utils.py`
    - `setup_simulation_argument_parser()`
    - `main_simulation_pipeline()`

## Import Usage

### New Modular Imports (Recommended)
```python
from spoiled_broth.simulations import SimulationConfig, SimulationRunner
from spoiled_broth.simulations import setup_simulation_argument_parser, main_simulation_pipeline

# Or import specific modules
from spoiled_broth.simulations.simulation_config import SimulationConfig
from spoiled_broth.simulations.simulation_runner import SimulationRunner
```

### Legacy Imports (Still Supported)
```python
from spoiled_broth.simulations.utils import (
    SimulationConfig,
    SimulationRunner,
    setup_simulation_argument_parser,
    main_simulation_pipeline
)
```

## Key Dependencies Between Modules

- `simulation_runner.py` imports most other modules as it orchestrates the simulation
- `data_logger.py` imports `action_tracker.py` to avoid circular imports
- `path_manager.py`, `controller_manager.py`, and `game_manager.py` all depend on `simulation_config.py`
- All imports use relative imports (`.module_name`) within the package

## Backward Compatibility

- The original `utils.py` file is preserved
- The `__init__.py` file imports all classes and functions, maintaining the same public API
- Existing code using imports from `spoiled_broth.simulations.utils` will continue to work
- New code can use the more specific module imports for better dependency management

## Benefits of Refactoring

1. **Better Organization**: Each class has its own focused file
2. **Easier Maintenance**: Changes to one class don't require editing a large file
3. **Clearer Dependencies**: Import relationships are more explicit
4. **Improved Testing**: Individual classes can be tested in isolation
5. **Reduced Merge Conflicts**: Multiple developers can work on different classes simultaneously
6. **Better IDE Support**: Faster loading and better autocomplete for smaller files

## CSV Output Documentation

The simulation and analysis modules generate several types of CSV files with detailed data for research analysis.

### Agent Actions CSV Files (`{agent_id}_actions.csv`)

Generated by `actions_extraction_like_humans.py`, these files contain comprehensive action-level data for each agent with item tracking and collaboration analysis.

#### Basic Action Data
- **`second`**: Timestamp in seconds when the action occurred (adjusted for initialization period)
- **`item`**: Type of item involved in the action (`tomato`, `plate`, `tomato_cut`, `tomato_salad`)
- **`item_id`**: Unique identifier for the specific item (e.g., `tomato_1`, `plate_2`)
- **`action`**: Type of action performed (`pickup`, `drop`, `cutting`)
- **`target_type`**: Type of target tile (`dispenser`, `counter`, `cuttingboard`, `delivery`)
- **`target_position`**: Tile coordinates where action was targeted (e.g., `(5, 3)`)
- **`action_long`**: Detailed description of the action category
- **`player_id`**: Agent identifier performing the action
- **`map_name`**: Name of the kitchen map used
- **`game_id`**: Simulation identifier

#### Movement and Performance Data
- **`distance_walked`**: Cumulative distance walked by agent in pixels
- **`distance_walked_since_last_action`**: Distance walked since previous action
- **`overall_score`**: Total score across all agents at this time point
- **`player_score_change`**: Change in this agent's score since last action
- **`player_score`**: Current score of this agent
- **`walking_speed`**: Agent walking speed (typically 1.0)
- **`cutting_speed`**: Agent cutting speed (typically 1.0)
- **`start_pos`**: Agent's starting position in tile coordinates

#### Item Tracking and History
- **`last_touched`**: Agent ID of the last agent to interact with this item
- **`touched_list`**: Semicolon-separated list of all agents who touched this item
- **`tomato_id`**: ID of the tomato associated with this item's lineage
- **`tomato_history`**: History of agents who touched the associated tomato
- **`plate_id`**: ID of the plate associated with this item's lineage
- **`plate_history`**: History of agents who touched the associated plate
- **`tomato_cut_id`**: ID of the cut tomato associated with this item's lineage
- **`tomato_cut_history`**: History of agents who touched the associated cut tomato
- **`tomato_salad_id`**: ID of the salad associated with this item's lineage
- **`tomato_salad_history`**: History of agents who touched the associated salad

#### Collaboration Analysis
- **`is_item_collaboration`**: `True` if multiple agents touched this specific item
- **`is_exchange_collaboration`**: `True` if multiple agents were involved in the item's creation lineage (e.g., it is enough if each of the agents touched at least once one of the items involved in the creation)
- **`who_picked_tomato`**: Agent ID who picked the tomato for this item
- **`who_picked_plate`**: Agent ID who picked the plate for this item
- **`who_cutted`**: Agent ID who cut the tomato for this item
- **`who_assembled`**: Agent ID who assembled the salad for this item
- **`who_delivered`**: Agent ID who delivered the salad
- **`proportion_of_collaboration`**: Array showing collaboration proportion per agent

#### Counter Usage Statistics
- **`number_of_counters_used`**: Total number of counter interactions across all related items
- **`number_of_counters_tomato`**: Counter interactions for the associated tomato
- **`number_of_counters_plate`**: Counter interactions for the associated plate
- **`number_of_counters_tomato_cut`**: Counter interactions for the associated cut tomato
- **`number_of_counters_tomato_salad`**: Counter interactions for the associated salad
- **`history_of_counters_used`**: Detailed history of all counter interactions (format: `agent:action@time`)
- **`history_of_counters_tomato`**: Counter history for tomato items
- **`history_of_counters_plate`**: Counter history for plate items
- **`history_of_counters_tomato_cut`**: Counter history for cut tomato items
- **`history_of_counters_tomato_salad`**: Counter history for salad items

### Agent Positions CSV Files (`{agent_id}_positions.csv`)

Generated by `positions_extraction_like_humans.py`, these files contain frame-by-frame position and state data for each agent.

#### Temporal Data
- **`second`**: Timestamp in seconds (adjusted so first second after initialization = 0)
- **`frame`**: Original frame number from simulation engine

#### Position Data
- **`x`**: Agent position in pixels (x-coordinate)
- **`y`**: Agent position in pixels (y-coordinate)
- **`tile_x`**: Agent position in tile coordinates (x-coordinate)
- **`tile_y`**: Agent position in tile coordinates (y-coordinate)

#### Movement Analysis
- **`distance_walked`**: Cumulative distance walked in pixels since start of meaningful actions
- **`walking_speed`**: Agent walking speed (typically 1.0)
- **`cutting_speed`**: Agent cutting speed (typically 1.0)
- **`start_pos`**: Agent's starting tile position (e.g., `"(2, 4)"`)

#### Agent State
- **`item`**: Item currently held by agent (`None` if empty-handed)
- **`score`**: Agent's current score

#### Timing Relationships

**Frame vs Second Conversion:**
- Raw simulation data uses `frame` numbers based on engine tick rate (typically 24 FPS)
- `second = frame / engine_tick_rate`
- Position files adjust timing to account for initialization period
- `second` in position files represents actual gameplay time (initialization period removed)
- Actions CSV uses the same adjusted timing for consistency

**Initialization Period:**
- Agents are positioned but perform no meaningful actions during initialization
- This period is filtered out to prevent analysis artifacts
- Position data `second` values start from 0 after initialization
- Duration typically 15+ seconds depending on agent loading time
- Configuration files contain exact initialization timing details

**Synchronization:**
- Actions and positions are synchronized using adjusted `second` values
- Frame numbers preserved for debugging and cross-referencing with raw simulation data
- Engine tick rate stored in configuration files for accurate frame-to-time conversion