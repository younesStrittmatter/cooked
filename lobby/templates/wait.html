<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Lobby</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
<main class="wrap">
    <div id="title">
        <p>Looking for another player...</p>

    </div>
    <section class="hints">
        <!-- Hint 1 -->
        <div class="hint">
            <div class="example-images">
                <img class="tl"
                     src="{{ url_for('static', filename='images/basic-counter.png') }}"
                     alt="Counter">
                <img class="tl"
                     src="{{ url_for('static', filename='images/tomato-dispenser.png') }}"
                     alt="Tomato Dispenser">
                <img class="tr"
                     src="{{ url_for('static', filename='images/basic-counter.png') }}"
                     alt="Counter">
                <img class="tr"
                     src="{{ url_for('static', filename='images/plate-dispenser.png') }}"
                     alt="Plate Dispenser">
            </div>
            <div class="example-hint">
                Pick up items by clicking on their dispensers or counters.
            </div>
        </div>
        <!-- Hint 2 -->
        <div class="hint">
            <div class="example-images">
                <img class="tm"
                     src="{{ url_for('static', filename='images/basic-counter.png') }}"
                     alt="Counter">
                <img class="tm"
                     src="{{ url_for('static', filename='images/cutting-board.png') }}"
                     alt="Cutting Board">
                <img class="tm"
                     src="{{ url_for('static', filename='images/knife-single.png') }}"
                     alt="Knife">
                <img class="tm"
                     src="{{ url_for('static', filename='images/tomato-on-board.png') }}"
                     alt="Tomato">
            </div>
            <div class="example-hint">
                Cut tomatoes on the cutting board.
            </div>
        </div>

        <!-- Hint 3 -->
        <div class="hint">
            <div class="example-images">
                <img class="tl"
                     src="{{ url_for('static', filename='images/cut-tomato.png') }}"
                     alt="Tomato(cut)">
                <img class="tr"
                     src="{{ url_for('static', filename='images/basic-counter.png') }}"
                     alt="Counter">
                <img class="tr"
                     src="{{ url_for('static', filename='images/plate.png') }}"
                     alt="Plate">
            </div>
            <div class="example-hint">
                Pick a cut tomato on a plate (or vice versa) to build a salad.
            </div>
        </div>

        <!-- Hint 4 -->
        <div class="hint">
            <div class="example-images">
                <img class="tl"
                     src="{{ url_for('static', filename='images/tomato-salad.png') }}"
                     alt="Tomato-salad">
                <img class="tr"
                     src="{{ url_for('static', filename='images/delivery.png') }}"
                     alt="Counter">
            </div>
            <div class="example-hint">
                Put the finished salad on the delivery counter to score.
            </div>
        </div>

        <!-- Hint 4 -->
        <div class="hint">
            <div class="example-images">
                <img class="tm"
                     src="{{ url_for('static', filename='images/basic-counter.png') }}"
                     alt="Counter">
            </div>
            <div class="example-hint">
                Each item can be placed on counters. This might be helpful to save walking time.
            </div>
        </div>

        <!-- Hint 5 -->
        <div class="hint">
            <div class="example-images">
                <img class="tl"
                     src="{{ url_for('static', filename='images/walk-slow.gif') }}"
                     alt="Slow walking">
                <img class="tr"
                     src="{{ url_for('static', filename='images/walk-fast.gif') }}"
                     alt="Fast walking">
            </div>
            <div class="example-hint">
                Cooks may (or may not) differ in how fast they walk.
            </div>
        </div>



        <!-- Hint 5 -->
        <div class="hint">
            <div class="example-images">
                <img class="tl"
                     src="{{ url_for('static', filename='images/chop-slow.gif') }}"
                     alt="Slow slicing">
                <img class="tr"
                     src="{{ url_for('static', filename='images/chop-fast.gif') }}"
                     alt="Fast slicing">
            </div>
            <div class="example-hint">
                Cooks may (or may not) differ in how fast they slice tomatoes.
            </div>
        </div>
    </section>
    <div id="Blocked-Warning" style="background-color:black; color:red; text-shadow: none;">
        <b>Warning!<br>
            Sometimes paths might be blocked, and clicking on objects and stations you can not reach will not
            have any effect. You might have to rely on your fellow cooks to get the job done.
        </b>
    </div>
    <div style="font-size: 18pt">
        <br>
<b>Each completed order earns bonus money for everyone. It
            doesn’t matter who sliced the tomato or who delivered the salad. The more orders you complete together as a
            team, the more each of you will earn.</b>
        <br>
    </div>
    <div>
        Please stay on this page until the game starts and do not close or refresh the page.
    </div>
    <div id="pastime">
        <div class="pastime">
            <div class="toolbar"
                 style="width: 50vw; margin: 3vh 21vw; padding: 2vw; border-radius: 2px;  background: #006b6b">
                <button id="soundBtn" class="btn secondary">Enable sound notification</button>
                <span id="tabHint" class="muted"
                      style="margin-left:auto; visibility: hidden">We’ll ping you when ready</span>
            </div>
            <div id="past-time-hint">
                To pass the time until the game starts, dodge the falling tomatoes (use left/right or A/D).
            </div>

            <!-- D-pad with centered canvas -->
            <div class="mini-wrap">
                <canvas id="mini" width="200" height="200" aria-label="warm-up"></canvas>

                <div class="touchpad" aria-label="Mini-game controls">

                    <button id="touch-left" class="touchbtn left" aria-label="Left"><span class="arrow"></span></button>
                    <button id="touch-right" class="touchbtn right" aria-label="Right"><span class="arrow"></span>
                    </button>

                </div>
            </div>
            <p id="miniScore" class="muted" style="margin:6px 0 0;">Tomatoes Dodged: 0</p>
            <p id="highscore" class="muted" style="margin: 6px 0 0;">Most Dodges: 0</p>
        </div>
    </div>
</main>

<script>
    (() => {
        const isTouch = (('ontouchstart' in window) || navigator.maxTouchPoints > 0)
            && matchMedia('(pointer: coarse)').matches;
        document.documentElement.classList.add(isTouch ? 'is-touch' : 'no-touch');

        // Update hint text if you have it in the DOM
        const hintEl = document.getElementById('past-time-hint');
        if (hintEl) {
            hintEl.textContent = isTouch
                ? 'To pass the time until the game starts, dodge the falling tomatoes (tap the arrows).'
                : 'To pass the time until the game starts, dodge the falling tomatoes (use left/right or A/D).';
        }

        // ------------- optional beep (needs a click) --------------
        let audioCtx = null;
        const soundBtn = document.getElementById('soundBtn');
        soundBtn?.addEventListener('click', () => {
            try {
                audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                // play a short test beep
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sine';
                o.frequency.value = 880;
                g.gain.value = 0.02;
                o.connect(g);
                g.connect(audioCtx.destination);
                o.start();
                setTimeout(() => {
                    o.stop()
                }, 150);
                soundBtn.disabled = true;
                soundBtn.textContent = 'Sound on';
                document.getElementById('tabHint').style.visibility = 'visible';
            } catch (_) {
            }
        });

        function beep() {
            if (!audioCtx) return;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = 'square';
            o.frequency.value = 1200;
            g.gain.value = 0.025;
            o.connect(g);
            g.connect(audioCtx.destination);
            o.start();
            setTimeout(() => {
                g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                o.stop(audioCtx.currentTime + 0.16);
            }, 10);
        }

        // -------------------- mini-game --------------------
        const canvas = document.getElementById('mini');
        const scoreEl = document.getElementById('miniScore');
        const highscoreEl = document.getElementById('highscore');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        let running = true, matched = false, last = performance.now(), score = 0;

        const player = {x: 100, y: 170, w: 14, h: 14, vx: 0};

        let hazards = [];
        let added_speed = 0

        function resetHazards() {
            hazards = [];
            added_speed = 0
            for (let i = 0; i < 6; i++) {
                hazards.push({
                    x: Math.random() * 190 + 5,
                    y: -Math.random() * 200,
                    r: 4 + Math.random() * 6,
                    vy: 40 + Math.random() * 90,
                    vx: 40 - Math.random() * 80,
                    isChasing: false,
                });
            }
        }

        resetHazards();

        const keys = window.keys ?? new Set(); // reuse if defined elsewhere
        window.keys = keys;

        addEventListener('keydown', e => {
            if (['ArrowLeft', 'ArrowRight',
                'a', 'd',
                'A', 'D'].includes(e.key)) {
                keys.add(e.key);
            }
        });
        addEventListener('keyup', e => keys.delete(e.key));

        // ---- Touch/Click buttons behave like holding Arrow keys ----
        function bindDirectionalButton(el, arrowKey, aliases = []) {
            const press = (ev) => {
                ev.preventDefault();
                el.dataset.active = "true";
                keys.add(arrowKey);
                // (Optional) also add WASD alias if your game watches those:
                aliases.forEach(k => keys.add(k));
                // Capture pointer so releasing outside still triggers release
                if (el.setPointerCapture && ev.pointerId != null) {
                    try {
                        el.setPointerCapture(ev.pointerId);
                    } catch {
                    }
                }
            };

            const release = (ev) => {
                ev.preventDefault();
                el.dataset.active = "false";
                keys.delete(arrowKey);
                aliases.forEach(k => keys.delete(k));
            };

            // Pointer Events support mouse, touch, stylus
            el.addEventListener('pointerdown', press, {passive: false});
            el.addEventListener('pointerup', release, {passive: false});
            el.addEventListener('pointercancel', release, {passive: false});
            el.addEventListener('pointerleave', (ev) => {
                // If finger/mouse slides off while pressed, keep holding until pointerup.
                // Comment out the next line if you prefer to release when leaving the button.
                // release(ev);
            }, {passive: false});

            // Prevent context menu on long-press
            el.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // Wire up buttons

        const leftBtn = document.getElementById('touch-left');
        const rightBtn = document.getElementById('touch-right');


        bindDirectionalButton(leftBtn, 'ArrowLeft', ['a', 'A']);
        bindDirectionalButton(rightBtn, 'ArrowRight', ['d', 'D']);
        addEventListener('keyup', e => keys.delete(e.key));

        let time_since_added_hazard = 0;
        let highscore = 0;
        let playerColor = '#4c8bf5';


        function step(dt) {
            const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
            const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');
            const up = keys.has('ArrowUp') || keys.has('w') || keys.has('W');
            const down = keys.has('ArrowDown') || keys.has('s') || keys.has('S');
            player.vx = (right ? 1 + added_speed / 100 : 0) - (left ? 1 + added_speed / 100 : 0);
            player.vy = (down ? 1 + added_speed / 100 : 0) - (up ? 1 + +added_speed / 100 : 0);
            player.x = Math.max(3, Math.min(197, player.x + player.vx * 140 * dt));
            player.y = Math.max(3, Math.min(197, player.y + player.vy * 140 * dt));
            time_since_added_hazard += dt;


            if (time_since_added_hazard > 1) {
                added_speed += 1
                time_since_added_hazard = 0;
                hazards.push({
                    x: Math.random() * 190 + 5,
                    y: -10,
                    r: 4 + Math.random() * 6,
                    vy: 40 + Math.random() * 90,
                    vx: 40 - Math.random() * 80,
                    isChasing: Math.random() < .5,
                });
            }
            hazards.forEach(h => {
                h.y += h.vy * dt;
                h.x += h.vx * dt;
                if (h.y > 210) {
                    h.y = -10;
                    h.x = Math.random() * 190 + 5;
                    h.vy = 40 + added_speed + Math.random() * 90;
                    h.vx = 40 + added_speed / 2 - Math.random() * (80 + added_speed);
                    if (h.isChasing) {
                        let speed = Math.sqrt(h.vx * h.vx + h.vy * h.vy);
                        h.vx += (player.x - h.x)
                        h.vy += (player.y - h.y)
                        const newSpeed = Math.sqrt(h.vx * h.vx + h.vy * h.vy);
                        h.vx = (h.vx / newSpeed) * speed
                        h.vy = (h.vy / newSpeed) * speed
                    }
                    score++;
                    if (score > highscore) {
                        highscore = score;
                    }
                }
            });
            let isNear = false
            for (const h of hazards) {
                let dodgeBonus = 3
                if (player.vx !== 0 || player.vy !== 0) {
                    dodgeBonus = 6
                }
                const dx = Math.abs(player.x - h.x) + dodgeBonus, dy = Math.abs(player.y - h.y) + dodgeBonus;
                if (dx < (player.w / 2 + h.r) && dy < (player.h / 2 + h.r)) {
                    score = 0
                    resetHazards()
                    break
                }
                if (dx < (player.w / 2 + h.r + 5) && dy < (player.h / 2 + h.r + 5)) {
                    isNear = isNear || true
                } else {
                    isNear = isNear || false
                }
            }
            playerColor = isNear ? '#f5a34c' : '#4c8bf5';
        }

        function draw(playerColor) {
            ctx.clearRect(0, 0, 200, 200);
            ctx.fillStyle = '#0b1222';
            ctx.fillRect(0, 0, 200, 200);
            ctx.fillStyle = playerColor;
            ctx.fillRect(player.x - player.w / 2, player.y - player.h / 2, player.w, player.h);
            ctx.fillStyle = '#f00';
            hazards.forEach(h => {
                ctx.beginPath();
                ctx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
                ctx.fill();
            });
        }


        function loop(now) {
            if (running) {
                const dt = Math.min(0.05, (now - last) / 1000);
                last = now;
                step(dt);
                draw(playerColor);
                if (scoreEl) scoreEl.textContent = 'Dodged Tomatoes: ' + score;
                if (highscore) highscoreEl.textContent = 'Most Dodges: ' + highscore;
            }
            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);

        document.addEventListener('visibilitychange', () => {
            running = !document.hidden && !matched;
        });

        // --------------- hook into your existing tick() ---------------
        // Wrap the original tick so we can beep/notify just before redirect.
        async function join() {
            let pid = new URLSearchParams(window.location.search).get('PROLIFIC_PID');
            if (!pid) pid = 'non_prolific_' + Math.random().toString(36).slice(2, 15);

            const params = new URLSearchParams(window.location.search);
            params.append("pid", pid);

            let shard_id = null;

            async function connect() {
                const r = await fetch("/connect?" + params.toString(), {method: "POST"});
                const j = await r.json().catch(() => ({}));
                if (j.connected) {
                    shard_id = j.shard_id;
                    setTimeout(check_back, 2000 + Math.random() * 3000);
                    return;
                }
                setTimeout(connect, 2000 + Math.random() * 3000);
            }

            let trigger_disconnect = true;

            async function check_back() {
                if (!shard_id) {
                    setTimeout(connect, 3000 + Math.random() * 3000);
                    return
                }
                const r = await fetch(`/check_back?${params.toString()}&shard_id=${encodeURIComponent(shard_id)}`, {method: "POST"});
                const j = await r.json().catch(() => ({}));
                if (j.redirect) {
                    beep?.();
                    trigger_disconnect = false;
                    setTimeout(() => location.href = j.redirect, 200);
                    return;
                }
                setTimeout(check_back, 2000 + Math.random() * 3000);
            }

            window.addEventListener("beforeunload", () => {
                if (shard_id && trigger_disconnect) navigator.sendBeacon(`/disconnect?shard_id=${encodeURIComponent(shard_id)}&pid=${encodeURIComponent(pid)}`);
            });

            connect();
        }

        join();
    })();
</script>

</body>
</html>
